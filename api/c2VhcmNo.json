[{"title":"movie_box","date":"2023-10-15T12:08:37.896Z","date_formatted":{"ll":"Oct 15, 2023","L":"10/15/2023","MM-DD":"10-15"},"updated":"2023-10-15T04:08:16.000Z","content":"movie_box\npython电影票房预测\n1.数据获取(spider)\n获取猫眼2018-2024年电影数据\n12345678910111213141516171819202122232425262728import requestsfrom bs4 import BeautifulSoupimport timeimport csvdata=&#123;    &#x27;user-agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.43&#x27;&#125;for year in range(2018, 2024):    url = f&quot;https://piaofang.maoyan.com/rankings/year?year=&#123;year&#125;&amp;limit=100&amp;tab=&#123;2024 - year&#125;&quot;    with open(f&#x27;&#123;year&#125;数据.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;, encoding=&#x27;utf-8&#x27;) as csvfile:        writer = csv.writer(csvfile)        writer.writerow([&#x27;电影名称&#x27;, &#x27;上映时间&#x27;, &#x27;票房（万元）&#x27;, &#x27;平均票价&#x27;, &#x27;观影人数&#x27;])        res=requests.get(url,headers=data)        time.sleep(2)        soup=BeautifulSoup(res.text,&#x27;lxml&#x27;)        res2=soup.find(&#x27;div&#x27;,id=&quot;ranks-list&quot;)        list_res2=res2.find_all(&#x27;ul&#x27;,class_=&quot;row&quot;)        for list in list_res2:            moviename = list.find(&#x27;p&#x27;,class_=&quot;first-line&quot;).text            uptime = list.find(&#x27;p&#x27;,class_=&quot;second-line&quot;).text            boxOffice = list.find(&#x27;li&#x27;,class_=&quot;col2 tr&quot;).text            aver_price = list.find(&#x27;li&#x27;,class_=&quot;col3 tr&quot;).text            num_p = list.find(&#x27;li&#x27;,class_=&quot;col4 tr&quot;).text            writer.writerow([moviename, uptime, boxOffice, aver_price, num_p])\n2.数据清洗\nA-python\n使用pandas中的dataframe格式存储数据信息并对数据进行清洗\n12345import pandas as pddata=pd.read_excel(io=&#x27;test.xlsx&#x27;)data_df=pd.DataFrame(data)new_data=pd.read_excel(io=&#x27;new_data.xlsx&#x27;)new_data_df=pd.DataFrame(new_data)\nB-sql\n将python爬取的数据使用json文件存储或excel文件存储导入数据库，或使用dbeaver将数据导入mysql中，在dbeaver中执行sql语句对数据进行数据清洗\n12345678910#python导入数据到mysqlimport mysql.connectorimport pandas as pdpysql=mysql.connector.connect(user=&#x27;root&#x27;,password=&#x27;123456&#x27;,host=&#x27;localhost&#x27;,database=&#x27;movie_box&#x27;)#选择数据库 if database is null,create a databasemy_cursor=mydb.cursor()data=pd.dataframe(&#x27;d:/*/&#x27;)sql=&#x27;insert &#123;****&#125; into talbe&#x27;my_cursor(sql)#使用游标执行sql语句(增删查改)\ndbeaver\n1234567#在dbeaver创建表映射导入数据#执行sql语句use movie_box;#database drop if (select *form movie_table)is null form movie_table;#去除与电影票房无关的数据，如时间drop time form movie_table;\n数据分析\n将与电影票房相关的信息作为特征值使用线性回归对未发行的电影进行票房预测\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from sklearn.linear_model import LinearRegressionimport pandas as pdimport numpy as npnew_movie=[]data=pd.read_excel(io=&#x27;test.xlsx&#x27;)data_df=pd.DataFrame(data)new_data=pd.read_excel(io=&#x27;new_data.xlsx&#x27;)new_data_df=pd.DataFrame(new_data)data_list1=[]data_list2=[]new_data_list=[]new_data_result=[]for i in range(len(new_data)):    data=[new_data.iloc[i][&#x27;a&#x27;],new_data.iloc[i][&#x27;d&#x27;],new_data.iloc[i][&#x27;e&#x27;]]#将一个电影的所有特征值作业放到一个列表中作为xi    #a=地区 b=场次 c=人次    new_data_list.append(data)#将xi插入到特征值列表中#print(new_data_list) for i in range(31):    data_=[data_df.loc[i,&#x27;a&#x27;],data_df.loc[i,&#x27;d&#x27;],data_df.loc[i,&#x27;e&#x27;]]#a=地区 b=场次 c=人次    data_list1.append(data_)    data_list2.append(data_df.loc[i,&#x27;c&#x27;])new_box=[]def BoxOffice(List_1,List_2,new_list):    #电影特征值 List1  票房List2    #new_list 新的预测票房的特征值列表    model=LinearRegression()    model.fit(List_1,List_2)      for i in new_list:        prediction=model.predict(np.array(i).reshape(1,-1))        new_box.append(prediction)# 在机器学习时，对随机值进行处理后可能会输出负值#而在发生复制的情况是场次大于人次BoxOffice(data_list1,data_list2,new_data_list)for i in new_box:    new_data_result.append(i[0])#print(data_df)#print(new_data_df)#print(new_data_result)\n数据可视化\n1.数据关联图\n部分数据与票房存在相关性，如地区与票房，可使用饼状图将其展示\n12345678910111213141516171819202122from pyecharts import options as optsfrom pyecharts.charts import Piefrom pyecharts.faker import Fakerpredlist_city=[&#x27;江苏&#x27;,&#x27;四川&#x27;,&#x27;天津&#x27;,&#x27;辽宁&#x27;,&#x27;内蒙古&#x27;,&#x27;重庆&#x27;]list_pred=[]for i in new_data_result:    list_pred.append(i)listdata_pred = [round(x, 2) for x in list_pred]c = (    Pie()    .add(        &quot;&quot;,        [list(z) for z in zip(predlist_city, listdata_pred)],        center=[&quot;35%&quot;, &quot;50%&quot;],    )    .set_global_opts(        title_opts=opts.TitleOpts(title=&quot;2023下半年\\n部分城市票房预测占比图&quot;),        legend_opts=opts.LegendOpts(pos_left=&quot;15%&quot;),    )    .set_series_opts(label_opts=opts.LabelOpts(formatter=&quot;&#123;b&#125;: \\n&#123;c&#125;&quot;))    .render(&#x27;232.html&#x27;))\n​​\n​​\n\t\t\t\t\t\t\t\t\t月度与票房占比\n\n2.票房预测图\n将票房预测结构与特征值使用柱状图输出结果\n12345678910111213141516171819202122232425BoxOffice(data_list1,data_list2,new_data)for i in new_box:    new_data_result.append(i[0])#print(df_1)#print(new_data_result)toptic_pre=new_data_result[10:20]pertic_list = [round(x, 2) for x in toptic_pre]#print(pertic_list)ticpre=pd.read_csv(r&#x27;排行榜数据-year.csv&#x27;)tic_datatop=ticpre.iloc[10:20]tic_data=tic_datatop[&#x27;票房（万元）&#x27;].tolist()filna_datatop=ticpre.iloc[10:20]filna_data=filna_datatop[&#x27;电影名称&#x27;].tolist()from pyecharts import options as optsfrom pyecharts.charts import Barfrom pyecharts.faker import Fakerc = (    Bar()    .add_xaxis(filna_data)    .add_yaxis(&quot;当前票房&quot;, tic_data)    .add_yaxis(&quot;预测票房&quot;, pertic_list)    .set_global_opts(title_opts=opts.TitleOpts(title=&quot;2023下半年票房预测&quot;, subtitle=&quot;&quot;))    .render(&#x27;233.html&#x27;))\n​​\n‍\n","plink":"https://wxx2786.github.io/2023/10/15/movie_box/"},{"title":"multivalued dependencies","date":"2023-10-15T12:04:39.310Z","date_formatted":{"ll":"Oct 15, 2023","L":"10/15/2023","MM-DD":"10-15"},"updated":"2023-10-15T04:04:22.000Z","content":"multivalued dependencies\nmultivalued dependencies\n\n\n多值依赖的意义\n\n\n多值依赖与函数依赖的区别\n\n\n多值依赖的定义\n\n\n多值依赖性质的证明(使用 temple 证明)\n传递性\n函数依赖可以看作是多值依赖的特殊情况\n并规则\n分解规则\n\n\n传递性\n若 X→→Y，Y→→Z，则 X→→Z-Y。\n证明该性质时，其存在两种特殊情况：\n① 在 X∩[Y∪Z]=Ø 时，设存在 U 的子集 X，Y，Z，K(X,Y,Z,K∈U)，其中 K=U-X-Y-Z。存在元组 S，T 属于关系 r(S,T∈r)且 S[X]=T[X],并将 YZ 元组分解 Y= (Y-Z)∪(Y∩Z)，Z= (Z-Y)∪(Y∩Z)，则有如表 1.3.3 下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nS\nS[X]\nS[Y-Z]\nS[Y∩Z]\nS[Z-Y]\nS[K]\n\n\nT\nT[X]\nT[Y-Z]\nT[Y∩Z]\nT[Z-Y]\nT[K]\n\n\n表 1.3.3\n由 X→→Y 可得，w，v 元组属于关系 r(W,V∈r)，则如表 1.3.4 下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nW\nW[X]\nS[Y-Z]\nS[Y∩Z]\nT[Z-Y]\nT[K]\n\n\nV\nV[X]\nT[Y-Z]\nT[Y∩Z]\nS[Z-Y]\nS[K]\n\n\n表 1.3.4\n其中 W[X]=V[X]=S[X]=T[X]。将现有 S,T,W,V 作为已知条件进行变换。\n若需要求得 X→→Z-Y 成立，则根据多值依赖的元组定义则需要证明以下元组 W’，V’满足 W’，V’属于关系 r(W’,V’∈r)，即如表 1.3.5 下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nW’\nS[X]\nT[Y-Z]\nT[Y∩Z]\nS[Z-Y]\nT[K]\n\n\nV’\nT[X]\nS[Y-Z]\nS[Y∩Z]\nT[Z-Y]\nS[K]\n\n\n表 1.3.5\n现对 S，W 元组由 Y→→Z 可得 W~1 ​~​~~,V~~​~1~ 元组，其中 Y= (Y-Z)∪(Y∩Z)，则有如表 1.3.6 下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nW~1~\nS[X]\nS[Y-Z]\nS[Y∩Z]\nS[Z-Y]\nT[K]\n\n\nV~1~\nS[X]\nS[Y-Z]\nS[Y∩Z]\nT[Z-Y]\nS[K]\n\n\n表 1.3.6\n同理，对 T，V 元组由 Y→→Z 可得 W~2 ​~​~~,V~~​~2~ 元组，其中 Y= (Y-Z)∪(Y∩Z) ，则有如表 1.3.7 下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nW~2~\nT[X]\nT[Y-Z]\nT[Y∩Z]\nT[Z-Y]\nS[K]\n\n\nV~2~\nT[X]\nT[Y-Z]\nT[Y∩Z]\nS[Z-Y]\nT[K]\n\n\n表 1.3.7\n又有 S[X]= T[X]，则可知 W’=V~2~，V’=V~1~，即 X→→Z-Y。\n②.在一般情况下，需要考虑元组 X 与元组 Y∪Z 的关系。设存在 U 的子集 X，Y，Z，K(X,Y,Z,K∈U)，其中 K=U-X-Y-Z，存在元组 S，T 属于关系 r(S,T∈r)且 S[X]=T[X]。现将 Y∪Z 分解：Y∪Z= [Y-Z]∪[Y∩Z]∪[Z-Y]，则需将元组 X 分解：X=X~0~∪X~1~∪X~2~∪X~3~，其中 X~1~=X∩(Y-Z),X~2~=X∩[Y∩Z],X~3~=X∩[Z-Y],X~0~=X-X~1~-X~2~-X~3~，即 X~0~，X~1~，X~2~，X~3~ 两两互不相交。则有如表 1.3.8 下列元组\n\n\n\nX~0~\nX~1~\nX~2~\nX~3~\nY-Z-X~1~\nY∩Z-X~2~\nZ-Y-X~3­~\nK\n\n\n\n\nS\nS[X~0~]\nS[X~1~]\nS[X~2~]\nS[X~3~]\nS[Y-Z-X~1~]\nS[Y∩Z-X~2~]\nS[Z-Y-X~3­~]\nS[K]\n\n\nT\nT[X~0~]\nT[X~1~]\nT[X~2~]\nT[X~3~]\nT[Y-Z-X~1~]\nT[Y∩Z-X~2~]\nT[Z-Y-X~3­~]\nT[K]\n\n\n表 1.3.8\n其中有 X→→Y 元组定义可得 S[X~i~] =T[X~i~] (i=1,2,3)，和新元组 W，V。则有如表 1.3.9 下列元组\n\n\n\nX~0~\nX~1~\nX~2~\nX~3~\nY-Z-X~1~\nY∩Z-X~2~\nZ-Y-X~3­~\nK\n\n\n\n\nW\nW[X~0~]\nS[X~1~]\nW[X~2~]\nW[X~3~]\nW[Y-Z-X~1~]\nW[Y∩Z-X~2~]\nW[Z-Y-X~3­~]\nW[K]\n\n\nV\nV[X~0~]\nV[X~1~]\nV[X~2~]\nT[X~3~]\nV[Y-Z-X~1~]\nV[Y∩Z-X~2~]\nV[Z-Y-X~3­~]\nV[K]\n\n\n表 1.3.9\n通过对比特殊情况与一般情况，则可发现在 Y→→Z 运用的过程中发生交换的元组分别为 Y-Z-X~1~, Y∩Z-X~2~, Z-Y-X~3~, K。即在一般情况下，通过 Y→→Z，(S,W)，(T,V)得到的新元组(W~1~,V~1~)，(W~2~,V~2~)其中(V~2~, V~1~)与所需要得到的 X→→Z-Y 的元组(W’,V’)相同。\n即在一般情况下，若 X→→Y，Y→→Z，则 X→→Z-Y 成立。\n[王壮_multivalued dependencies_whpu.pdf](assets/王壮_multivalued dependencies_whpu-20231013121646-6kctkqh.pdf)\n","plink":"https://wxx2786.github.io/2023/10/15/multivalued dependencies/"},{"title":"贪心算法","date":"2023-10-15T11:09:08.364Z","date_formatted":{"ll":"Oct 15, 2023","L":"10/15/2023","MM-DD":"10-15"},"updated":"2023-10-15T11:25:44.995Z","content":"贪心算法\n贪心算法，又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好/最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好/最优的解。\n贪婪法的基本步骤：\n步骤 1：从某个初始解出发；\n步骤 2：采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；\n步骤 3：将所有解综合起来。\n最短路\n​​\n最短路算法总结（超详细~）-CSDN 博客\ndijkstra\n\n每次从未标记的节点中寻找距离出发点最近的节点，标记，收录到最优路径集合中\n计算刚加入的节点 A 到相邻节点 B 的距离，不包括已标记的节点\n若 节点A到源点的距离​ + 节点A到节点B的边长​ &lt; 节点B到源点的距离​，更新节点 B 到源点的值\n重复以上步骤，直到未标记的节点未空时，停止算法\n\n【算法】最短路径查找—Dijkstra 算法_哔哩哔哩_bilibili\n1234567891011121314void dijkstra(int dist[], bool st[], int grid[][N])&#123;    dist[x] = 0;    for(int i = 1; i&lt;=n; i++)    &#123;        int t = -1;//标记最小权值点        for(int j = 1; j&lt;=n; j++)//寻找最小权值点            if(st[j] == false &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))                t = j;        st[t] = true;        for(int j = 1; j&lt;=n; j++)            dist[j] = min(dist[j], dist[t] + grid[t][j]);    &#125;&#125;\nbellman_ford\n优点\n\n和 dijkstra 不同的是，BF 算法可以解决负环的最短路径问题，同时可以判断负环是否存在。\n环：从某个顶点出发、经过若干个不同的顶点，可以回到该顶点的情况。\n零环、正环、负环\n\n思路\n\n\n初始化源点 s 到各个点 v 的路径 dis[v] = ∞，dis[s] = 0​。\n\n\n进行 n - 1 次遍历，每次遍历对所有边进行松弛操作，满足则将权值更新。\n松弛操作：以 a 为起点，b 为终点，ab 边长度为 w 为例。dis[a]代表源点 s 到 a 点的路径长度，dis[b]代表源点 s 到 b 点的路径长度。如果满足下面的式子则将 dis[b]​ 更新为 dis[a] + w​。\n\n​dis[b] &gt; dis[a] + w​\n\n\n\n遍历都结束后，若再进行一次遍历，还能得到 s 到某些节点更短的路径的话，则说明存在负环路。\n理由在于：对于给定 n 个节点的图，从 i 到 j，最短路径至多有 n-1 条路径，当出现 n 条路径时，说明在该条路径上至少存在一个环，也就是如果在进行一次遍历，如果节点的最短路径还能得到更新，那么只有环存在时，才会更新路径\n\n\n123456789101112131415161718192021222324252627282930313233343536struct edge&#123;\tint v, w;//v是出边，w是当前点到出边v的权值&#125;;vector&lt;edge&gt; e[maxn];int dis[maxn];const int inf = 0x3f3f3f3f;bool bellmanford(int s)&#123;\tmemset(dis, 0x3f, sizeof(dis));\tdis[s] = 0;\tbool flag; // 判断一轮循环过程中是否发生松弛操作\tfor (int i = 1; i &lt;= n; i++)//至多遍历n-1次得到最短路径\t&#123;\t\tflag = false;\t\tfor (int u = 1; u &lt;= n; u++)//依次遍历每一个点\t\t&#123;\t\t\tif (dis[u] == inf)//当前点到源点还不存在路径时，不更新该点，理由如下\t\t\t\tcontinue;// 无穷大与常数加减仍然为无穷大，因此最短路长度为 inf 的点引出的边不可能发生松弛操作\t\t\tfor (auto ed : e[u])//遍历当前点的所有邻边\t\t\t&#123;\t\t\t\tint v = ed.v, w = ed.w;\t\t\t\tif (dis[v] &gt; dis[u] + w)\t\t\t\t&#123;\t\t\t\t\tdis[v] = dis[u] + w;\t\t\t\t\tflag = true;//存在松弛操作，打上标记\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tif (!flag)// 没有可以松弛的边时就停止算法\t\t\tbreak;\t&#125;\t// 第 n 轮循环仍然可以松弛时说明 s 点可以抵达一个【负环】\treturn flag;&#125;\n‍\nfloyd\n**视频讲解：**​最短路径（二）Floyd 算法_哔哩哔哩_bilibili\n\n解决图中任意点到某一点之间的最短路问题，例如 P 点到 M 点，中间可以直达也可以经过其他点到达\n\n在视频中拓展：\n\n$A_{n*n}$ 矩阵依据公式 $a_{ij} = min(a_{ij},a_{ik} + a_{kj})$ 迭代 n 次后得到 i 到 j 的最短路径，但是得不到经过那些点，可以用一个额外的数组来记录经过的点，在视频讲解的末尾位置\n$A_{n*n}$ 矩阵依据公式 $a_{ij} = min(a_{ij},max(a_{ik}, a_{kj}))$ 可以得到 i 到 j 的所有通路集合中的通路的最大边的的最小值，就是在这一堆通路中，每条通路都有一条最大的边，在将这些边中的最小值取出\n\n1234567891011//针对无向图void floyd()&#123;    //设k为中间节点，检查从i到j的距离和i到k，k到j（即以k作为中间节点绕行）的距离\tfor(int k=0; k&lt;n; k++)&#123;        for(int i = 0; i&lt;n; i++)&#123;            for(int j = 0; j&lt;n; j++)&#123;                grid[i][j] = grid[j][i] = min(grid[i][j], grid[i][k] + grid[k][j]);            &#125;        &#125;    &#125;&#125;\n最小生成树\nprim\nPrim （普里姆）算法是另一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。具有贪心的思想。\n具体来说，每次要选择距离集合（已访问点集合）最小的一个结点，以及用新的边更新其他结点的距离。\n其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。\n堆优化的方式类似 Dijkstra 的堆优化，但如果使用二叉堆等不支持 decrease-key 的堆，复杂度就不优于 Kruskal，常数也比 Kruskal 大。所以，一般情况下都使用 Kruskal 算法，在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但 不一定 实际跑得更快。\n时间复杂度：O(n^2)​\n流程\n\n初始化：dist[N]为所有点到集合的距离，初始化为无穷大\n任选一个点，然后将该点加入最短路集合\n寻找距离到最短路集合最近的点，同时将该点加入最短路集合中\n遍历该点的邻接点，更新邻接点到集合的距离 dist\n重复三四步骤，n 次循环，即遍历 n 个点，得到最小生成树\n\n思路\n在每一次选择一个点加入最小生成树集合中后，都会更新该点的所有邻接点到集合的距离，我们只要维护 dist 这个距离就可以得到答案，例如\n第一次循环：在选取第一个点的时候，t = 0，vis[0]==true​，更新了该点的所有邻接点到 0 点的距离\n第二次循环：选取了到 0 点最近的一个点，加入最小生成树集合，更新该点的所有邻接点到该点的距离\n重复 n 次循环，也就是 n 个点，值得注意的是，我们每次选取的都是这个集合的所有邻接点，而这些邻接点都被更新过了，因此是可以得到答案的。\n同时：还需要注意，如果在除开第一次选的点以外的点中，找到一个到集合距离无穷大的点，那么也就是说这个点是孤立点，一定是无法构成最小生成树的，即可返回 impossible​\n12345678910111213141516171819202122232425int grid[N][N], n, m;int dist[N], vis[N];int prim()&#123;    memset(dist, 0x3f, sizeof(dist));    int sum = 0;    for(int i = 0; i&lt;n; i++)&#123;        int t = -1;        for(int j = 1; j&lt;=n; j++)&#123;            if(!vis[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        &#125;        vis[t] = true;        //如果该点非第一个点，但是该点到集合的距离是无穷大，也就是说该点是孤立出来的        if(i &amp;&amp; dist[t] == INF)            return INF;                if(i)//该点非第一个点            sum += dist[t];            for(int j = 1; j&lt;=n; j++)            dist[j] = min(dist[j], grid[t][j]);    &#125;       return sum;&#125;\nkruskal\nKruskal （克鲁斯克尔）算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。\n使用：并查集、图的存储、贪心\n例题：4291. 丛林之路 - AcWing 题库\n时间复杂度：O(mlogm)​（m 是边数）\n流程\n\n将所有边按权值从小到大排序，时间复杂度 O(mlogm)​\n依次遍历所有边，如果某边的两点不构成回路，即加入最短路径集合\n统计最短路径集合中的边个数，如果小于 n-1，即不构成最小生成树，等于 n-1，即可构成最小生成树\n\n123456789101112131415161718192021222324252627282930313233struct edge&#123;    int a, b, w;//始点，终点，权&#125;edges[M];int p[N], cnt;void add(int a, int b, int w)&#123;    edges[cnt].a = a, edges[cnt].b = b, edges[cnt].w = w, cnt++;&#125;int find(int x)&#123;\tif(p[x] != x)        p[x] = find(p[x]);\treturn p[x];&#125;int kruskal()&#123;    for(int i = 1; i&lt;=n; i++) p[i] = i;    sort(edges, edges + cnt);    int sum = 0, en = 0;//权值和，路径条数    for(int i = 0; i&lt;cnt; i++)&#123;\t\tint a = edges[i].a, b = edges[i].b, w = edges[i].w;        int pa = find(a), pb = find(b);        if(pa != pb)&#123;            p[pa] = pb;            sum += w;            en++;        &#125;    &#125;    if(en &lt; n - 1)&#123;        cout &lt;&lt; &quot;无法构成最小生成树&quot;;        return -1;    &#125;    return sum;&#125;\n","plink":"https://wxx2786.github.io/2023/10/15/贪心算法/"},{"title":"wxx2786的主页","date":"2023-10-15T11:09:08.360Z","date_formatted":{"ll":"Oct 15, 2023","L":"10/15/2023","MM-DD":"10-15"},"updated":"2023-10-12T01:01:24.000Z","content":"wxx2786的主页\n项目经验\npython电影票房预测\n1.数据获取(spider)\n获取猫眼2018-2024年电影数据\n12345678910111213141516171819202122232425262728import requestsfrom bs4 import BeautifulSoupimport timeimport csvdata=&#123;    &#x27;user-agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.43&#x27;&#125;for year in range(2018, 2024):    url = f&quot;https://piaofang.maoyan.com/rankings/year?year=&#123;year&#125;&amp;limit=100&amp;tab=&#123;2024 - year&#125;&quot;    with open(f&#x27;&#123;year&#125;数据.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;, encoding=&#x27;utf-8&#x27;) as csvfile:        writer = csv.writer(csvfile)        writer.writerow([&#x27;电影名称&#x27;, &#x27;上映时间&#x27;, &#x27;票房（万元）&#x27;, &#x27;平均票价&#x27;, &#x27;观影人数&#x27;])        res=requests.get(url,headers=data)        time.sleep(2)        soup=BeautifulSoup(res.text,&#x27;lxml&#x27;)        res2=soup.find(&#x27;div&#x27;,id=&quot;ranks-list&quot;)        list_res2=res2.find_all(&#x27;ul&#x27;,class_=&quot;row&quot;)        for list in list_res2:            moviename = list.find(&#x27;p&#x27;,class_=&quot;first-line&quot;).text            uptime = list.find(&#x27;p&#x27;,class_=&quot;second-line&quot;).text            boxOffice = list.find(&#x27;li&#x27;,class_=&quot;col2 tr&quot;).text            aver_price = list.find(&#x27;li&#x27;,class_=&quot;col3 tr&quot;).text            num_p = list.find(&#x27;li&#x27;,class_=&quot;col4 tr&quot;).text            writer.writerow([moviename, uptime, boxOffice, aver_price, num_p])\n2.数据清洗\nA-python\n使用pandas中的dataframe格式存储数据信息并对数据进行清洗\n12345import pandas as pddata=pd.read_excel(io=&#x27;test.xlsx&#x27;)data_df=pd.DataFrame(data)new_data=pd.read_excel(io=&#x27;new_data.xlsx&#x27;)new_data_df=pd.DataFrame(new_data)\nB-sql\n将python爬取的数据使用json文件存储或excel文件存储导入数据库，或使用dbeaver将数据导入mysql中，在dbeaver中执行sql语句对数据进行数据清洗\n12345678910#python导入数据到mysqlimport mysql.connectorimport pandas as pdpysql=mysql.connector.connect(user=&#x27;root&#x27;,password=&#x27;123456&#x27;,host=&#x27;localhost&#x27;,database=&#x27;movie_box&#x27;)#选择数据库 if database is null,create a databasemy_cursor=mydb.cursor()data=pd.dataframe(&#x27;d:/*/&#x27;)sql=&#x27;insert &#123;****&#125; into talbe&#x27;my_cursor(sql)#使用游标执行sql语句(增删查改)\ndbeaver\n1234567#在dbeaver创建表映射导入数据#执行sql语句use movie_box;#database drop if (select *form movie_table)is null form movie_table;#去除与电影票房无关的数据，如时间drop time form movie_table;\n数据分析\n将与电影票房相关的信息作为特征值使用线性回归对未发行的电影进行票房预测\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from sklearn.linear_model import LinearRegressionimport pandas as pdimport numpy as npnew_movie=[]data=pd.read_excel(io=&#x27;test.xlsx&#x27;)data_df=pd.DataFrame(data)new_data=pd.read_excel(io=&#x27;new_data.xlsx&#x27;)new_data_df=pd.DataFrame(new_data)data_list1=[]data_list2=[]new_data_list=[]new_data_result=[]for i in range(len(new_data)):    data=[new_data.iloc[i][&#x27;a&#x27;],new_data.iloc[i][&#x27;d&#x27;],new_data.iloc[i][&#x27;e&#x27;]]#将一个电影的所有特征值作业放到一个列表中作为xi    #a=地区 b=场次 c=人次    new_data_list.append(data)#将xi插入到特征值列表中#print(new_data_list) for i in range(31):    data_=[data_df.loc[i,&#x27;a&#x27;],data_df.loc[i,&#x27;d&#x27;],data_df.loc[i,&#x27;e&#x27;]]#a=地区 b=场次 c=人次    data_list1.append(data_)    data_list2.append(data_df.loc[i,&#x27;c&#x27;])new_box=[]def BoxOffice(List_1,List_2,new_list):    #电影特征值 List1  票房List2    #new_list 新的预测票房的特征值列表    model=LinearRegression()    model.fit(List_1,List_2)      for i in new_list:        prediction=model.predict(np.array(i).reshape(1,-1))        new_box.append(prediction)# 在机器学习时，对随机值进行处理后可能会输出负值#而在发生复制的情况是场次大于人次BoxOffice(data_list1,data_list2,new_data_list)for i in new_box:    new_data_result.append(i[0])#print(data_df)#print(new_data_df)#print(new_data_result)\n数据可视化\n1.数据关联图\n部分数据与票房存在相关性，如地区与票房，可使用饼状图将其展示\n12345678910111213141516171819202122from pyecharts import options as optsfrom pyecharts.charts import Piefrom pyecharts.faker import Fakerpredlist_city=[&#x27;江苏&#x27;,&#x27;四川&#x27;,&#x27;天津&#x27;,&#x27;辽宁&#x27;,&#x27;内蒙古&#x27;,&#x27;重庆&#x27;]list_pred=[]for i in new_data_result:    list_pred.append(i)listdata_pred = [round(x, 2) for x in list_pred]c = (    Pie()    .add(        &quot;&quot;,        [list(z) for z in zip(predlist_city, listdata_pred)],        center=[&quot;35%&quot;, &quot;50%&quot;],    )    .set_global_opts(        title_opts=opts.TitleOpts(title=&quot;2023下半年\\n部分城市票房预测占比图&quot;),        legend_opts=opts.LegendOpts(pos_left=&quot;15%&quot;),    )    .set_series_opts(label_opts=opts.LabelOpts(formatter=&quot;&#123;b&#125;: \\n&#123;c&#125;&quot;))    .render(&#x27;232.html&#x27;))\n​​\n​​\n\t\t\t\t\t\t\t\t\t月度与票房占比\n\n2.票房预测图\n将票房预测结构与特征值使用柱状图输出结果\n12345678910111213141516171819202122232425BoxOffice(data_list1,data_list2,new_data)for i in new_box:    new_data_result.append(i[0])#print(df_1)#print(new_data_result)toptic_pre=new_data_result[10:20]pertic_list = [round(x, 2) for x in toptic_pre]#print(pertic_list)ticpre=pd.read_csv(r&#x27;排行榜数据-year.csv&#x27;)tic_datatop=ticpre.iloc[10:20]tic_data=tic_datatop[&#x27;票房（万元）&#x27;].tolist()filna_datatop=ticpre.iloc[10:20]filna_data=filna_datatop[&#x27;电影名称&#x27;].tolist()from pyecharts import options as optsfrom pyecharts.charts import Barfrom pyecharts.faker import Fakerc = (    Bar()    .add_xaxis(filna_data)    .add_yaxis(&quot;当前票房&quot;, tic_data)    .add_yaxis(&quot;预测票房&quot;, pertic_list)    .set_global_opts(title_opts=opts.TitleOpts(title=&quot;2023下半年票房预测&quot;, subtitle=&quot;&quot;))    .render(&#x27;233.html&#x27;))\n​​\n","plink":"https://wxx2786.github.io/2023/10/15/wxx2786的主页/"},{"title":"wxx_note","date":"2023-10-15T11:09:08.358Z","date_formatted":{"ll":"Oct 15, 2023","L":"10/15/2023","MM-DD":"10-15"},"updated":"2023-10-14T15:54:09.595Z","content":"wxx_note\nAboat major\n‍\nmultivalued dependencies\n\n\n多值依赖的意义\n\n\n多值依赖与函数依赖的区别\n\n\n多值依赖的定义\n\n\n多值依赖性质的证明(使用temple证明)\n传递性\n函数依赖可以看作是多值依赖的特殊情况\n并规则\n分解规则\n\n\n传递性\n若X→→Y，Y→→Z，则X→→Z-Y。\n证明该性质时，其存在两种特殊情况：\n①在X∩[Y∪Z]=Ø时，设存在U的子集X，Y，Z，K(X,Y,Z,K∈U)，其中K=U-X-Y-Z。存在元组S，T属于关系r(S,T∈r)且S[X]=T[X],并将YZ元组分解Y= (Y-Z)∪(Y∩Z)，Z= (Z-Y)∪(Y∩Z)，则有如表1.3.3下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nS\nS[X]\nS[Y-Z]\nS[Y∩Z]\nS[Z-Y]\nS[K]\n\n\nT\nT[X]\nT[Y-Z]\nT[Y∩Z]\nT[Z-Y]\nT[K]\n\n\n表1.3.3\n由X→→Y可得，w，v元组属于关系r(W,V∈r)，则如表1.3.4下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nW\nW[X]\nS[Y-Z]\nS[Y∩Z]\nT[Z-Y]\nT[K]\n\n\nV\nV[X]\nT[Y-Z]\nT[Y∩Z]\nS[Z-Y]\nS[K]\n\n\n表1.3.4\n其中W[X]=V[X]=S[X]=T[X]。将现有S,T,W,V作为已知条件进行变换。\n若需要求得X→→Z-Y成立，则根据多值依赖的元组定义则需要证明以下元组W’，V’满足W’，V’属于关系r(W’,V’∈r)，即如表1.3.5下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nW’\nS[X]\nT[Y-Z]\nT[Y∩Z]\nS[Z-Y]\nT[K]\n\n\nV’\nT[X]\nS[Y-Z]\nS[Y∩Z]\nT[Z-Y]\nS[K]\n\n\n表1.3.5\n现对S，W元组由Y→→Z可得W~1 ​~​~~,V~~​~1~元组，其中Y= (Y-Z)∪(Y∩Z)，则有如表1.3.6下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nW~1~\nS[X]\nS[Y-Z]\nS[Y∩Z]\nS[Z-Y]\nT[K]\n\n\nV~1~\nS[X]\nS[Y-Z]\nS[Y∩Z]\nT[Z-Y]\nS[K]\n\n\n表1.3.6\n同理，对T，V元组由Y→→Z可得W~2 ​~​~~,V~~​~2~元组，其中Y= (Y-Z)∪(Y∩Z) ，则有如表1.3.7下列元组\n\n\n\nX\nY-Z\nY∩Z\nZ-Y\nK\n\n\n\n\nW~2~\nT[X]\nT[Y-Z]\nT[Y∩Z]\nT[Z-Y]\nS[K]\n\n\nV~2~\nT[X]\nT[Y-Z]\nT[Y∩Z]\nS[Z-Y]\nT[K]\n\n\n表1.3.7\n又有S[X]= T[X]，则可知W’=V~2~，V’=V~1~，即X→→Z-Y。\n②.在一般情况下，需要考虑元组X与元组Y∪Z的关系。设存在U的子集X，Y，Z，K(X,Y,Z,K∈U)，其中K=U-X-Y-Z，存在元组S，T属于关系r(S,T∈r)且S[X]=T[X]。现将Y∪Z分解：Y∪Z= [Y-Z]∪[Y∩Z]∪[Z-Y]，则需将元组X分解：X=X~0~∪X~1~∪X~2~∪X~3~，其中X~1~=X∩(Y-Z),X~2~=X∩[Y∩Z],X~3~=X∩[Z-Y],X~0~=X-X~1~-X~2~-X~3~，即X~0~，X~1~，X~2~，X~3~两两互不相交。则有如表1.3.8下列元组\n\n\n\nX~0~\nX~1~\nX~2~\nX~3~\nY-Z-X~1~\nY∩Z-X~2~\nZ-Y-X~3­~\nK\n\n\n\n\nS\nS[X~0~]\nS[X~1~]\nS[X~2~]\nS[X~3~]\nS[Y-Z-X~1~]\nS[Y∩Z-X~2~]\nS[Z-Y-X~3­~]\nS[K]\n\n\nT\nT[X~0~]\nT[X~1~]\nT[X~2~]\nT[X~3~]\nT[Y-Z-X~1~]\nT[Y∩Z-X~2~]\nT[Z-Y-X~3­~]\nT[K]\n\n\n表1.3.8\n其中有X→→Y元组定义可得S[X~i~] =T[X~i~] (i=1,2,3)，和新元组W，V。则有如表1.3.9下列元组\n\n\n\nX~0~\nX~1~\nX~2~\nX~3~\nY-Z-X~1~\nY∩Z-X~2~\nZ-Y-X~3­~\nK\n\n\n\n\nW\nW[X~0~]\nS[X~1~]\nW[X~2~]\nW[X~3~]\nW[Y-Z-X~1~]\nW[Y∩Z-X~2~]\nW[Z-Y-X~3­~]\nW[K]\n\n\nV\nV[X~0~]\nV[X~1~]\nV[X~2~]\nT[X~3~]\nV[Y-Z-X~1~]\nV[Y∩Z-X~2~]\nV[Z-Y-X~3­~]\nV[K]\n\n\n表1.3.9\n通过对比特殊情况与一般情况，则可发现在Y→→Z运用的过程中发生交换的元组分别为Y-Z-X~1~, Y∩Z-X~2~, Z-Y-X~3~, K。即在一般情况下，通过Y→→Z，(S,W)，(T,V)得到的新元组(W~1~,V~1~)，(W~2~,V~2~)其中(V~2~, V~1~)与所需要得到的X→→Z-Y的元组(W’,V’)相同。\n即在一般情况下，若X→→Y，Y→→Z，则X→→Z-Y成立。\n[王壮_multivalued dependencies_whpu.pdf](assets/王壮_multivalued dependencies_whpu-20231013121646-6kctkqh.pdf)\nIntelligent algorithms\n[王壮_Intelligent algorithms_whpu.pdf](assets/王壮_Intelligent algorithms_whpu-20231013121739-h3ngilg.pdf)\nAboat algorithm\n‍\n动态规划\n01背包\n1234567891011121314151617#二维数组版const int w[1024],c[1024]int n,m;cin&gt;&gt;n&gt;&gt;m;for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;c[i];for(int i=1;j&lt;=n;j++)//i是物品个数\tfor(int j=1;j&lt;=m;j++)//j是背包空间\t\tif(j&lt;w[i]) dp[i][j]=dp[i-1][j];\t\teles dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+c[i])cout&lt;&lt;dp[n][m];#一维数组版int n,m;cin&gt;&gt;n&gt;&gt;m;for(int i=1;i&lt;=n;i++)&#123;\tint v,m;cin&gt;&gt;v&gt;&gt;m;\tfor(int j=m;j&gt;=v;j--) dp[j]=max(dp[j-1],dp[j-v]+m);&#125;//从m最大值开始遍历且最小值大于物品体积是为保证能够加入物品cout&lt;&lt;dp[m];\n\n逐渐添加元素入背包，然后求在每个容量下的最大值(利用动态转移)\n在逐渐增加背包容量下，当容量小于添加元素的体积时，该状态下的最大值v1与该容量下未添加元素时的最大值v2相同，而在大于添加元素的体积时，该状态需判断添加新元素与剩余空间所对应的值之和v3与未添加时的值v1的大小，取最大值\n\n带你学透0-1背包问题！| 关于背包问题，你不清楚的地方，这里都讲了！| 动态规划经典问题 | 数据结构与算法_哔哩哔哩_bilibili\n完全背包\n\n\n最直接版完全背包\n1234567int n,m; cin&gt;&gt;n&gt;&gt;m;for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;c[i];for(int i=1;i&lt;=n;i++)\tfor(int j=1;j&lt;m;j++)\t\tfor(int k=0;k&lt;j/w[i];k++)\t\t\tdp[j]=max(dp[j],dp[j-k*w[i]]+k*c[i]);cout&lt;&lt;dp[m];\n\n\n​​优化版二维完全背包​\n在完全背包问题中，物品可多项选择，及可以竖向转移—在未添加新物品时该容量下的值(01背包问题原理)，和竖向转移—在添加新物品的情况加进行动态规划(及在j-W[i]的背包大小所对应的值加上C[i]值)，然后取最大值。\n12345678int n,m; cin&gt;&gt;n&gt;&gt;m;for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;c[i];for(int i=1;i&lt;=n;i++)\tfor(int j=1;j&lt;m;j++)&#123;\t\tdp[i][j]=dp[i-1][j];//竖向转移\t\tif(j-w[i]&gt;=0)\tdp[i][j]=max(dp[i][j],dp[i][j-w[i]]+c[i]);//横向转移&#125;cout&lt;&lt;dp[n][m];\n\n\n最简版完全背包问题\n123456int n,m; cin&gt;&gt;n&gt;&gt;m;for(int i=1;i&lt;=n;i++) cin&gt;&gt;w[i]&gt;&gt;c[i];for(int i=1;i&lt;=n;i++)\tfor(int j=w[i];j&lt;=m;j++)&#123;\t\tdp[j]=max(dp[j],dp[j-w[i]]+c[i]);cout&lt;&lt;dp[m];\n\n\n背包九讲系列1——01背包、完全背包、多重背包 - 简书 (jianshu.com)\n贪心算法\n贪心算法，又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，选取当前状态下最好/最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果也是最好/最优的解。\n贪婪法的基本步骤：\n步骤1：从某个初始解出发；\n步骤2：采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；\n步骤3：将所有解综合起来。\n最短路\n​​\n最短路算法总结（超详细~）-CSDN博客\ndijkstra\n\n每次从未标记的节点中寻找距离出发点最近的节点，标记，收录到最优路径集合中\n计算刚加入的节点A到相邻节点B的距离，不包括已标记的节点\n若 节点A到源点的距离​ + 节点A到节点B的边长​ &lt; 节点B到源点的距离​，更新节点B到源点的值\n重复以上步骤，直到未标记的节点未空时，停止算法\n\n【算法】最短路径查找—Dijkstra算法_哔哩哔哩_bilibili\n1234567891011121314void dijkstra(int dist[], bool st[], int grid[][N])&#123;    dist[x] = 0;    for(int i = 1; i&lt;=n; i++)    &#123;        int t = -1;//标记最小权值点        for(int j = 1; j&lt;=n; j++)//寻找最小权值点            if(st[j] == false &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))                t = j;        st[t] = true;        for(int j = 1; j&lt;=n; j++)            dist[j] = min(dist[j], dist[t] + grid[t][j]);    &#125;&#125;\nbellman_ford\n优点：\n\n和dijkstra不同的是，BF算法可以解决负环的最短路径问题，同时可以判断负环是否存在。\n环：从某个顶点出发、经过若干个不同的顶点，可以回到该顶点的情况。\n零环、正环、负环\n\n思路：\n\n\n初始化源点s到各个点v的路径dis[v] = ∞，dis[s] = 0​。\n\n\n进行n - 1次遍历，每次遍历对所有边进行松弛操作，满足则将权值更新。\n松弛操作：以a为起点，b为终点，ab边长度为w为例。dis[a]代表源点s到a点的路径长度，dis[b]代表源点s到b点的路径长度。如果满足下面的式子则将dis[b]​更新为dis[a] + w​。\n\n​dis[b] &gt; dis[a] + w​\n\n\n\n遍历都结束后，若再进行一次遍历，还能得到s到某些节点更短的路径的话，则说明存在负环路。\n理由在于：对于给定n个节点的图，从i到j，最短路径至多有n-1条路径，当出现n条路径时，说明在该条路径上至少存在一个环，也就是如果在进行一次遍历，如果节点的最短路径还能得到更新，那么只有环存在时，才会更新路径\n\n\n123456789101112131415161718192021222324252627282930313233343536struct edge&#123;\tint v, w;//v是出边，w是当前点到出边v的权值&#125;;vector&lt;edge&gt; e[maxn];int dis[maxn];const int inf = 0x3f3f3f3f;bool bellmanford(int s)&#123;\tmemset(dis, 0x3f, sizeof(dis));\tdis[s] = 0;\tbool flag; // 判断一轮循环过程中是否发生松弛操作\tfor (int i = 1; i &lt;= n; i++)//至多遍历n-1次得到最短路径\t&#123;\t\tflag = false;\t\tfor (int u = 1; u &lt;= n; u++)//依次遍历每一个点\t\t&#123;\t\t\tif (dis[u] == inf)//当前点到源点还不存在路径时，不更新该点，理由如下\t\t\t\tcontinue;// 无穷大与常数加减仍然为无穷大，因此最短路长度为 inf 的点引出的边不可能发生松弛操作\t\t\tfor (auto ed : e[u])//遍历当前点的所有邻边\t\t\t&#123;\t\t\t\tint v = ed.v, w = ed.w;\t\t\t\tif (dis[v] &gt; dis[u] + w)\t\t\t\t&#123;\t\t\t\t\tdis[v] = dis[u] + w;\t\t\t\t\tflag = true;//存在松弛操作，打上标记\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tif (!flag)// 没有可以松弛的边时就停止算法\t\t\tbreak;\t&#125;\t// 第 n 轮循环仍然可以松弛时说明 s 点可以抵达一个【负环】\treturn flag;&#125;\nfolyd\n设定矩阵$A_{n*n}$，其中\n$$\na_{ij}=\\left{\n\\begin{matrix}0,i=j\n\\c_{i,j}, (i,j)\\in E\n\\ \\infty , (i,j)\\notin  E\n\\end{matrix}\\right.\n$$\n**视频讲解：**​最短路径（二）Floyd算法_哔哩哔哩_bilibili\n\n解决图中任意点到某一点之间的最短路问题，例如P点到M点，中间可以直达也可以经过其他点到达\n\n在视频中拓展：\n\n$A_{n*n}$矩阵依据公式$a_{ij} = min(a_{ij},a_{ik} + a_{kj})$迭代n次后得到i到j的最短路径，但是得不到经过那些点，可以用一个额外的数组来记录经过的点，在视频讲解的末尾位置\n$A_{n*n}$矩阵依据公式$a_{ij} = min(a_{ij},max(a_{ik}, a_{kj}))$可以得到i到j的所有通路集合中的通路的最大边的的最小值，就是在这一堆通路中，每条通路都有一条最大的边，在将这些边中的最小值取出\n\n1234567891011//针对无向图void floyd()&#123;    //设k为中间节点，检查从i到j的距离和i到k，k到j（即以k作为中间节点绕行）的距离\tfor(int k=0; k&lt;n; k++)&#123;        for(int i = 0; i&lt;n; i++)&#123;            for(int j = 0; j&lt;n; j++)&#123;                grid[i][j] = grid[j][i] = min(grid[i][j], grid[i][k] + grid[k][j]);            &#125;        &#125;    &#125;&#125;\n最小生成树\nprim\nPrim （普里姆）算法是另一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。具有贪心的思想。\n具体来说，每次要选择距离集合（已访问点集合）最小的一个结点，以及用新的边更新其他结点的距离。\n其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。\n堆优化的方式类似 Dijkstra 的堆优化，但如果使用二叉堆等不支持 decrease-key 的堆，复杂度就不优于 Kruskal，常数也比 Kruskal 大。所以，一般情况下都使用 Kruskal 算法，在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但 不一定 实际跑得更快。\n时间复杂度：O(n^2)​\n流程：\n\n初始化：dist[N]为所有点到集合的距离，初始化为无穷大\n任选一个点，然后将该点加入最短路集合\n寻找距离到最短路集合最近的点，同时将该点加入最短路集合中\n遍历该点的邻接点，更新邻接点到集合的距离dist\n重复三四步骤，n次循环，即遍历n个点，得到最小生成树\n\n思路：\n在每一次选择一个点加入最小生成树集合中后，都会更新该点的所有邻接点到集合的距离，我们只要维护dist这个距离就可以得到答案，例如\n第一次循环：在选取第一个点的时候，t = 0，vis[0]==true​，更新了该点的所有邻接点到0点的距离\n第二次循环：选取了到0点最近的一个点，加入最小生成树集合，更新该点的所有邻接点到该点的距离\n重复n次循环，也就是n个点，值得注意的是，我们每次选取的都是这个集合的所有邻接点，而这些邻接点都被更新过了，因此是可以得到答案的。\n同时：还需要注意，如果在除开第一次选的点以外的点中，找到一个到集合距离无穷大的点，那么也就是说这个点是孤立点，一定是无法构成最小生成树的，即可返回impossible​\n12345678910111213141516171819202122232425int grid[N][N], n, m;int dist[N], vis[N];int prim()&#123;    memset(dist, 0x3f, sizeof(dist));    int sum = 0;    for(int i = 0; i&lt;n; i++)&#123;        int t = -1;        for(int j = 1; j&lt;=n; j++)&#123;            if(!vis[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        &#125;        vis[t] = true;        //如果该点非第一个点，但是该点到集合的距离是无穷大，也就是说该点是孤立出来的        if(i &amp;&amp; dist[t] == INF)            return INF;                  if(i)//该点非第一个点            sum += dist[t];              for(int j = 1; j&lt;=n; j++)            dist[j] = min(dist[j], grid[t][j]);    &#125;       return sum;&#125;\nkruskal\nKruskal （克鲁斯克尔）算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。\n使用：并查集、图的存储、贪心\n例题：4291. 丛林之路 - AcWing题库\n时间复杂度：O(mlogm)​（m是边数）\n流程：\n\n将所有边按权值从小到大排序，时间复杂度O(mlogm)​\n依次遍历所有边，如果某边的两点不构成回路，即加入最短路径集合\n统计最短路径集合中的边个数，如果小于n-1，即不构成最小生成树，等于n-1，即可构成最小生成树\n\n123456789101112131415161718192021222324252627282930313233struct edge&#123;    int a, b, w;//始点，终点，权&#125;edges[M];int p[N], cnt;void add(int a, int b, int w)&#123;    edges[cnt].a = a, edges[cnt].b = b, edges[cnt].w = w, cnt++;&#125;int find(int x)&#123;\tif(p[x] != x)        p[x] = find(p[x]);\treturn p[x];&#125;int kruskal()&#123;    for(int i = 1; i&lt;=n; i++) p[i] = i;    sort(edges, edges + cnt);    int sum = 0, en = 0;//权值和，路径条数    for(int i = 0; i&lt;cnt; i++)&#123;\t\tint a = edges[i].a, b = edges[i].b, w = edges[i].w;        int pa = find(a), pb = find(b);        if(pa != pb)&#123;            p[pa] = pb;            sum += w;            en++;        &#125;    &#125;    if(en &lt; n - 1)&#123;        cout &lt;&lt; &quot;无法构成最小生成树&quot;;        return -1;    &#125;    return sum;&#125;\n","plink":"https://wxx2786.github.io/2023/10/15/wxx_note/"}]