{"title":"多生产者多消费者(线程池实现)","date":"2023-10-22T15:32:50.273Z","date_formatted":{"ll":"Oct 22, 2023","L":"10/22/2023","MM-DD":"10-22"},"link":"2023/10/22/线程池","tags":["C++/thread"],"categories":["C++"],"updated":"2023-10-22T15:36:26.209Z","content":"<h1 id=\"一-多生产者多消费者模型\">一 多生产者多消费者模型<a title=\"#一-多生产者多消费者模型\" href=\"#一-多生产者多消费者模型\"></a></h1>\n<h2 id=\"什么是生产者-消费者模式\"><strong>什么是生产者-消费者模式</strong><a title=\"#什么是生产者-消费者模式\" href=\"#什么是生产者-消费者模式\"></a></h2>\n<p>比如有两个进程A和B，它们共享一个<strong>固定大小的缓冲区</strong>，A进程产生数据放入缓冲区，B进程从缓冲区中取出数据进行计算，那么这里其实就是一个生产者和消费者的模式，A相当于生产者，B相当于消费者</p>\n<p>​<img src=\"https://pic2.zhimg.com/80/v2-1a026b35fb94b42b79429fa3c850059d_720w.webp\" alt=\"\" loading=\"lazy\"></p>\n<h2 id=\"生产者-消费者模式的特点\"><strong>生产者-消费者模式的特点</strong><a title=\"#生产者-消费者模式的特点\" href=\"#生产者-消费者模式的特点\"></a></h2>\n<ul>\n<li>保证生产者不会在缓冲区满的时候继续向缓冲区放入数据，而消费者也不会在缓冲区空的时候，消耗数据</li>\n<li>当缓冲区满的时候，生产者会进入休眠状态，当下次消费者开始消耗缓冲区的数据时，生产者才会被唤醒，开始往缓冲区中添加数据；当缓冲区空的时候，消费者也会进入休眠状态，直到生产者往缓冲区中添加数据时才会被唤醒</li>\n</ul>\n<p>‍</p>\n<p>​<img src=\"https://pic3.zhimg.com/80/v2-6e19e7ed5fafca7d87ffd236f6fb7a5e_720w.webp\" alt=\"\" loading=\"lazy\">​</p>\n<h1 id=\"二-线程池\">二 线程池<a title=\"#二-线程池\" href=\"#二-线程池\"></a></h1>\n<h2 id=\"什么是线程池？\">什么是线程池？<a title=\"#什么是线程池？\" href=\"#什么是线程池？\"></a></h2>\n<p>线程池是一种利用池化技术思想来实现的线程管理技术，主要是为了复用线程、便利地管理线程和任务、并将线程的创建和任务的执行解耦开来。我们可以创建线程池来复用已经创建的线程来降低频繁创建和销毁线程所带来的资源消耗。在JAVA中主要是使用ThreadPoolExecutor类来创建线程池，并且JDK中也提供了Executors工厂类来创建线程池（不推荐使用）。</p>\n<h2 id=\"为什么使用线程池？\">为什么使用线程池？<a title=\"#为什么使用线程池？\" href=\"#为什么使用线程池？\"></a></h2>\n<p>‍</p>\n<p>​<img src=\"https://pic2.zhimg.com/80/v2-9b7cb50bc3bbddbd331dc1630b33ecdd_720w.webp\" alt=\"\" loading=\"lazy\"></p>\n<p>从上面可以看出之前显示的创建线程的一些缺点：</p>\n<ul>\n<li>不受控制风险，对于每个创建的线程没有统一管理的地方，每个线程创建后我们不知道线程的去向。</li>\n<li>每执行一个任务都需要创建新的线程来执行，创建线程对系统来说开销很高</li>\n</ul>\n<h1 id=\"三-多生产者多消费者模型使用线程池实现\">三 多生产者多消费者模型使用线程池实现<a title=\"#三-多生产者多消费者模型使用线程池实现\" href=\"#三-多生产者多消费者模型使用线程池实现\"></a></h1>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> bufferSize = <span class=\"number\">10</span>;</span><br><span class=\"line\">std::queue&lt;<span class=\"type\">int</span>&gt;buffer;\t </span><br><span class=\"line\">std::mutex mtx;</span><br><span class=\"line\">std::condition_variable producer_cv;</span><br><span class=\"line\">std::condition_variable cosumer_cv;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">productor</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstd::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono::<span class=\"built_in\">milliseconds</span>(<span class=\"number\">1000</span>));</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> item = <span class=\"built_in\">rand</span>() % <span class=\"number\">100</span>;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tstd::unique_lock&lt;std::mutex&gt;<span class=\"built_in\">lock</span>(mtx);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (buffer.<span class=\"built_in\">size</span>() &lt; bufferSize) &#123;</span><br><span class=\"line\">\t\t\t\tbuffer.<span class=\"built_in\">push</span>(item);</span><br><span class=\"line\">\t\t\t\tstd::cout &lt;&lt; <span class=\"string\">&quot;Producer&quot;</span> &lt;&lt; id &lt;&lt;<span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"string\">&quot;produce&quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class=\"line\">\t\t\t\tcosumer_cv.<span class=\"built_in\">notify_all</span>();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cosumer</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> item;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tstd::unique_lock&lt;std::mutex&gt;<span class=\"built_in\">lock</span>(mtx);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (buffer.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\t\t\tcosumer_cv.<span class=\"built_in\">wait</span>(lock);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\titem = buffer.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">\t\t\tbuffer.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tstd::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono::<span class=\"built_in\">milliseconds</span>(<span class=\"number\">1500</span>));</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; <span class=\"string\">&quot;Cosumer&quot;</span> &lt;&lt; id &lt;&lt;<span class=\"string\">&quot; &quot;</span> &lt;&lt; <span class=\"string\">&quot;cosume&quot;</span> &lt;&lt; item &lt;&lt; std::endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tstd::vector&lt;std::thread&gt;threadspoll;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> numProducer = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"type\">int</span> numconsumer = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numProducer; i++) &#123;</span><br><span class=\"line\">\t\tthreadspoll.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">thread</span>(productor, i));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numconsumer; i++) &#123;</span><br><span class=\"line\">\t\tthreadspoll.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">thread</span>(cosumer, i));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;i : threadspoll) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ti.<span class=\"built_in\">join</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>‍</p>\n","prev":{"title":"QT_random_program","link":"2023/10/24/Qt多线程实现随机数生成及冒泡快排输出"},"next":{"title":"多线程与多进程","link":"2023/10/20/多线程与多进程"},"plink":"https://wxx2786.github.io/2023/10/22/线程池/","toc":[{"id":"一-多生产者多消费者模型","title":"一 多生产者多消费者模型","index":"1","children":[{"id":"什么是生产者-消费者模式","title":"什么是生产者-消费者模式","index":"1.1"},{"id":"生产者-消费者模式的特点","title":"生产者-消费者模式的特点","index":"1.2"}]},{"id":"二-线程池","title":"二 线程池","index":"2","children":[{"id":"什么是线程池？","title":"什么是线程池？","index":"2.1"},{"id":"为什么使用线程池？","title":"为什么使用线程池？","index":"2.2"}]},{"id":"三-多生产者多消费者模型使用线程池实现","title":"三 多生产者多消费者模型使用线程池实现","index":"3"}],"reading_time":"771 words in 5 min"}